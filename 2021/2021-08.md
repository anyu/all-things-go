## 2021-08-03

#### idiom/best practice
- Use full sentences with periods for doc comments; facilitates becoming godoc docs. ([GoCodeReview](https://github.com/golang/go/wiki/CodeReviewComments#comment-sentences))
- Error strings should not be capitalized or end w/ punctuation (unless proper nouns, acronyms); does not apply to logging (since usually not combined w/ other messages) ([GoCodeReview](https://github.com/golang/go/wiki/CodeReviewComments#error-strings))
- Use `crypto/rand` instead of `math/rand` for key generation - `math/rand` is too predictable (entirely so when unseeded, just a little entropy when seeded) ([GoCodeReview](https://github.com/golang/go/wiki/CodeReviewComments#crypto-rand))
- Prefer actual != expected vs the inverse in test fail messages ([GoCodeReview](https://github.com/golang/go/wiki/CodeReviewComments#useful-test-failures))
```go
if got != tt.want {
	t.Errorf("Foo(%q) = %d; want %d", tt.in, got, tt.want)
}
```

#### design
- Consider returning additional value to indicate validity in cases where caller would need to handle result differently, vs. returning in-band errors, such as -1/nil ([GoCodeReview](https://github.com/golang/go/wiki/CodeReviewComments#in-band-errors))
- eg. `func Lookup(key string) (value string, ok bool)`

#### terminology
- "naked return" = a return statement without arguments returning the named return values

#### language

- `nil` is not a keyword in Go, it's a predefined identifier. It does not have a default type.
- nil types are not equal (nil pointer != nil interface), but nil values can satisfy interfaces
- `var s []string // nil slice` > `t := []string{} // non-nil, but zero-length`. Functionally equivalent, but former is preferred style.
  Caveat: Latter is useful in certain cases, eg. JSON-encoding: (`nil` slice encodes to `null`, `[]string{}` encodes to `[]`. ([GoCodeReview](https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices))

**Nil slices:** `var s []string`

| Action      			    | Behavior
| :-- | :--------------------------------
| len(s) | 0
| cap(s) | 0
| for range s | iterates 0 times
| s[i] | panic: index out of range


**Nil maps:** `var m map[t]u`

| Action      			    | Behavior
| :-- | :--------------------------------
| len(m) | 0
| for range m | iterates 0 times
| v, ok := m[i] | zero(u), false
| m[i] = x | panic: assignment to entry in nil map

Use `nil` maps as read-only empty maps


**Nil channels:** `var c chan t`

| Action      			    | Behavior
| :-- | :--------------------------------
| <- c | blocks forever
| c <- x | blocks forever
| close(c) | panic: close of nil channel

***Closed* channels:** `var c chan t`

| Action      			    | Behavior
| :-- | :--------------------------------
| v, ok <- c | zero(t), false
| c <- x | panic: send on closed channel
| close(c) | panic: close of nil channel

When a channel is closed, if you receive something on it, it'll return 0 and not block.
So might want to check closed status.

```go
var aClosed bool

select {
case v, ok := <-a:
	if !ok {
        aClosed = true
        continue
    }
...
}
```

Even if channel has received, once done, may need to close the channel to prevent deadlock.

But once a channel is closed, it no longer blocks. So, use nil channels to disable select cases (*switch off* channel,
but make sure not to close it)

```go
case v, ok := <-a:
	if !ok {
        a = nil
        fmt.Println("a is now closed")
        continue
    }
...
```
([GopherCon 2016: Francesc Campoy - Understanding nil](https://www.youtube.com/watch?v=ynoY2xz-F8s))
